/******************************************************************************
*                              SofaPython3 plugin                             *
*                  (c) 2021 CNRS, University of Lille, INRIA                  *
*                                                                             *
* This program is free software; you can redistribute it and/or modify it     *
* under the terms of the GNU Lesser General Public License as published by    *
* the Free Software Foundation; either version 2.1 of the License, or (at     *
* your option) any later version.                                             *
*                                                                             *
* This program is distributed in the hope that it will be useful, but WITHOUT *
* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or       *
* FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License *
* for more details.                                                           *
*                                                                             *
* You should have received a copy of the GNU Lesser General Public License    *
* along with this program. If not, see <http://www.gnu.org/licenses/>.        *
*******************************************************************************
* Contact information: contact@sofa-framework.org                             *
******************************************************************************/
#pragma once

#include <SofaPython3/config.h>
#include <sofa/helper/logging/Messaging.h>
#include <string>
#include <vector>
#include <regex>
#include <pybind11/pybind11.h>

namespace sofapython3
{

class PythonMethodDescription
{
public:
    void add_entry(const std::string& signature="")
    {
        signatures.push_back(signature);
        docstrings.push_back("");
    }

    /// Parse the docstring generated by pybind11 to extract the different method signatures
    /// and for each the associated docstring.
    void parse_docstring(const std::string& name, std::string docstring)
    {
        std::smatch m;
        std::string last;
        std::regex e;

        if(signatures.size()==0)
            return;

        // easy path. Take the signature, then consider the remaining as a docstring
        if(signatures.size()==1)
        {
            e = std::regex("("+name+".*)");
            if (std::regex_search (docstring, m,e))
            {
                for (auto x:m)
                    last = x;
                if(signatures[0].size()==0)
                    signatures[0] = last;
                docstrings[0] = m.suffix().str();
            }
            return;
        }

        int idx = 0;
        e = std::regex("(1\\. )("+name+".*)");
        while (std::regex_search (docstring, m,e))
        {
            for (auto x:m)
                last = x;

            if(signatures[idx].size()==0)
                signatures[idx] = last;

            if(idx>0)
                docstrings[idx-1] = m.prefix().str();
            idx++;
            docstring = m.suffix().str();

            auto pex = "("+std::to_string(idx+1)+"\\. )("+name+".*)";
            e = std::regex(pex);
        }
        if(!docstring.empty())
            docstrings[idx-1] = docstring;
    }

    /// Generates the docstring from the extracted ones from pybind11 and applying the
    /// customs signatures, if any.
    const std::string build_docstring(const std::string& name) const
    {
        std::stringstream tmp;
        if(signatures.size() == 1)
        {
            tmp << signatures[0];
            tmp << docstrings[0];
            return tmp.str();
        }
        else
        {
            tmp << name <<"(*args, **kwargs)\n";
            tmp << "Overloaded function.\n\n";
        }
        for(unsigned int i=0;i<docstrings.size();i++)
        {
            tmp << (i+1) << ". " << signatures[i] ;
            tmp << docstrings[i] ;
        }
        return tmp.str();
    }

private:
    std::vector<std::string> signatures; //< signatures for the method overrides
    std::vector<std::string> docstrings; //< docstrings for the method overrides

};

template<typename Class>
class def_method
{
public:
    def_method(Class classI, const std::string& name_) :
        classInstance(classI), name(name_)
    {
    }

    virtual ~def_method()
    {
        description.parse_docstring(name, get_current_docstring());
        set_docstring(description.build_docstring(name));
    }

    template<typename ... Args>
    def_method& add_override(Args ... args)
    {
        classInstance.def(name.c_str(), args...);
        description.add_entry();
        return *this;
    }

    template<typename ... Args>
    def_method& add_override(const char* signature, Args ... args)
    {
        classInstance.def(name.c_str(), args...);
        description.add_entry(signature);
        return *this;
    }

    std::string get_current_docstring() const {
        std::string tmp;
        // get the raw python object out of the classInstance
        auto method = classInstance.attr(name.c_str()).ptr();
        // if it is an instance method get the raw CFunction
        if(Py_TYPE(method) == &PyInstanceMethod_Type){
            method = ((PyInstanceMethodObject*)(method))->func;
        }
        // if it is a CFunction, get its docstring
        if(Py_TYPE(method) == &PyCFunction_Type){
            auto cmethod = (PyCFunctionObject*)method;
            tmp = std::string(cmethod->m_ml->ml_doc);
        }
        return tmp;
    }

    void set_docstring(const std::string& docstring) const
    {
        // get the raw python object out of the classInstance
        auto method = classInstance.attr(name.c_str()).ptr();
        // if it is an instance method get the raw CFunction
        if(Py_TYPE(method) == &PyInstanceMethod_Type){
            method = ((PyInstanceMethodObject*)(method))->func;
        }
        // if it is a CFunction, get its docstring
        if(Py_TYPE(method) == &PyCFunction_Type){
            auto cmethod = (PyCFunctionObject*)method;
            cmethod->m_ml->ml_doc = strdup(docstring.c_str());
        }else
        {
            msg_error("SofaPython3") << "Unable to build docstring for method " << name;
        }
    }

private:
    Class classInstance; //< stores the pybind::class_<XXX, >
    std::string name;    //< stores the name of the method we declares
    PythonMethodDescription description;
};

}
